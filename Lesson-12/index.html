<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-12</title>
</head>
<body>
    <h2>Асинхронний JavaScript</h2>
    <p>Є два типи стилю асинхронного коду, з якими ви зіткнетеся в коді JavaScript,
        старий метод - колбеки (callbacks) і новий - проміси (promises)
    </p>
    <p>Зверніть увагу, що асинхронний - це не те ж саме, що й одночасний або
        багатопотоковий. JavaScript може мати асинхронний код, але він, як правило,
        однопотоковий. Це як в ресторані з одним працівником, який робить все: подача
        і приготування їжі. Але якщо цей працівник працює досить швидко і може
        перемикатися між завданнями досить ефективно, то буде здаватися, що у
        ресторані є кілька робітників.
        В асинхронних багатопотокових процесах ви призначаєте завдання працівникам.
        В асинхронних однопотокових процесах у вас є графік завдань, де деякі завдання
        залежать від інших. У міру виконання кожного завдання викликається код, який
        планує наступне завдання, яке може бути запущено, з урахуванням результатів
        щойно виконаного завдання. Але вам потрібний лише один працівник для
        виконання всіх завдань, а не один працівник на завдання.
    </p>
    <h2>setTimeout и setInterval</h2>
    <p>Ми можемо вирішити виконати функцію не зараз, а через певний час пізніше. Це
        називається “планування виклику”. <br>
        Для цього існує два методи: <br>
        setTimeout дозволяє нам запускати функцію один раз через певний інтервал
        часу. <br>
        setInterval дозволяє нам запускати функцію багаторазово, починаючи через
        певний інтервал часу, а потім постійно повторюючи у цьому інтервалі. <br>
        Ці методи не є частиною специфікації JavaScript. Але більшість середовищ
        виконання JS-коду мають внутрішній планувальник і надають ці методи. Зокрема,
        вони підтримуються у всіх браузерах та Node.js.
    </p>
    <h2>setTimeout</h2>
    <p>Синтаксис: <br>
        let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...) <br>
        Параметри: <br>
        func|code <br>
        Функція або рядок коду для виконання. Зазвичай це функція. З історичних
        причин можна передати рядок коду, але це не рекомендується. <br>
        delay <br>
        Затримка перед запуском, у мілісекундах (1000 мс = 1 секунда), типове значення –
        0. <br>
        arg1, arg2… <br>
        Аргументи, які передаються у функцію (не підтримується в IE9-)
    </p>
    <h2>Скасування за допомогою clearTimeout</h2>
    <p>Виклик setTimeout повертає “ідентифікатор таймера” timerId, який ми можемо
        використовувати для скасування виконання. <br>
        Синтаксис для скасування: <br>
        let timerId = setTimeout(...); <br>
        clearTimeout(timerId); <br>
        У наведеному нижче коді ми плануємо функцію, а потім скасовуємо її (просто передумали). В
        результаті нічого не відбувається: <br>
        let timerId = setTimeout(() => alert("ніколи не відбувається"), 1000); <br>
        alert(timerId); // ідентифіка тор таймера <br>
        clearTimeout(timerId); <br>
        alert(timerId); // той самий ідентифікатор (не приймає значення null після скасування) <br>
        Як ми бачимо з результату alert, в браузері ідентифікатор таймера – це число. В інших
        середовищах це може бути щось інше. Наприклад, Node.js повертає об’єкт таймера з
        додатковими методами.
    </p>
    <h2>setInterval</h2>
    <p>Метод setInterval має той самий синтаксис, що і setTimeout: <br>
        let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...) <br>
        Усі аргументи мають такі ж самі значення. Але на відміну від setTimeout, цей метод
        запускає функцію не один раз, але регулярно через заданий проміжок часу.
        Щоб припинити подальші виклики, нам слід викликати clearInterval (timerId).
        Наступний приклад буде відображати повідомлення кожні 2 секунди. Через 5 секунд
        вивід припиняється: <br>
        // повторити з інтервалом 2 секунди br
        let timerId = setInterval(() => alert('тік'), 2000); <br>
        // зупинити через 5 секунд br
        setTimeout(() => { clearInterval(timerId); ale
    </p>
    <button id="start">Start</button>
    <button id="stop">Stop</button>
    <h2>Date - об'єкт для роботи з датою та часом</h2>
    <p>Синтаксис: <br>
        new Date(); <br>
        new Date(value); <br>
        new Date(year, month, date[, hours[, minutes[, seconds[,ms]]]]); <br>
        Параметри: <br>
        value - значення в якому задається дата і час. Значення буває: числове і рядкове. <br>
        Якщо значення числове то вказується кількість мілісекунд від 01.01.1970 00:00:00.
        Якщо значення рядкове то вказується рядкове предсавлення дати і часу у форматі
        який розпізнає метод Date.parse(). <br>
        year - Обов'язковий параметр. Число яке вказує рік. <br>
        У різних браузерах рік вказується по різному: двох значними числами 00 до 99 і
        чотирьох значними числами.
        Рекомендовано вказувати чотирьох значне число, наприклад: 2016. Для сумісності з
        браузерами.
    </p>
    <p>month - Обов'язковий параметр. <br>
        Вказується місяць від 0 до 11, де: <br>
        0 - січень <br>
        1 - лютий <br>
        2 - березень <br>
        3 - квітень <br>
        4 - травень <br>
        5 - червень <br>
        6 - липень <br>
        7 - серпень <br>
        8 - вересень <br>
        9 - жовтень <br>
        10 - листопад <br>
        11 - грудень <br>
    </p>
    <p>date - Обов'язковий параметр. День від 1 до 31. <br>
        hours - година від 0 до 23. <br>
        minutes - хвилина від 0 до 59. <br>
        seconds - секунди від 0 до 59. <br>
        ms - мілісекунди від 0 до 999. <br>
        Об'єкт Date служить для отримання дати і часу і для роботи з датою і часом. <br>
        При створенні об'єкту Date використання оператора new є обов'язкове. Інакше 
        об'єкт не буде створено а повернеться рядок з поточною датою.
        Якщо при створені об'єкту Date не вказано жодного параметру то об'єкту
        присвоюється поточна системна дата і час.
        У JavaScript дата і час вимірюється у мілісекундах які пройшли з 01.01.1970 по UTC
        (Всесвітній координований час).
        Місцевий час у JavaScript це час на локальному комп'ютері, на якому виконується
        JavaScript
    </p>
    <h2>Властивості об'єкта Date:</h2>
    <p>Date.length- кількість параметрів.</p> <br> 
    <h2>Методи об'єкта Date: </h2>
    <p>Date.now() - число мілісекунд з 01.01.1970. <br>
        Date.parse() - розбирає рядкове представленя дати і повертає у мілісекундах. <br>
        Date.UTC() - повертає мілісекунди у вказаній даті. <br>
        Date.getDate() - повертає день. <br>
        Date.getDay() - повертає номер дня у тижні. <br>
        Date.getFullYear() - повертає рік. <br>
        Date.getHours() - повертає годину <br>
        Date.getMonth() - повертає місяць. <br>
        Date.getMinutes() - повертає хвилини. <br>
    </p>
    <p>Date.getSeconds() - повертає секунди. <br>
        Date.getMilliseconds() - повертає мілісекунди. <br>
        Date.getTime() - повертає кількість мілісекунд у даті. <br>
        Date.getTimezoneOffset() - зміщення часового поясу у хвилинах. <br>
        Date.getUTCDate() - повертає день у форматі UTC. <br>
        Властивості об'єкта Date: <br>
        Date.length- кількість параметрів. <br>
    </p>
    <p>Date.getUTCDay() - повертає номер дня у тижні у форматі UTC. <br>
        Date.getUTCFullYear() - повертає рік у форматі UTC. <br>
        Date.getUTCHours() - повертає годину у форматі UTC. <br>
        Date.getVarDate() - повертає значення VT_DATE. <br>
        Date.getYear() - повертає значення рік-1990. <br>
        Date.setDate - встановлює день місяця. <br>
        Date.setFullYear - встановлює рік. <br>
        Date.setHours - встановлює годину. <br>
        Date.setMinutes() - встановлює хвилину. <br>
        Date.setMonth() - встановлює місяць. <br>
        Date.setTime() - встановлює дату по вказаним мілісекундам. <br>
        Date.setUTCDate() - встановлює день місяця по UTC. <br>
        Date.setUTCFullYear() - встановлює рік по UTC. <br>
        Data.setUTCHours - встановлює годину по UTC. <br>
        Data.setUTCMilliseconds - встановлює мілісекунди по UTC. <br>
        Date.setUTCMinutes() - встановлює хвилини по UTC <br>
        Date.setYear() - встановлює рік. <br>
        Date.toDateString() - повертає рядок з датою. <br>
        Date.toGMTString() - повертає рядок з датою і часом по GMT. <br>
        Date.toJSON - повертає дату і час у рядку відформатовану для JSON. <br>
        Date.toLocaleDateString() - повертає рядок з лише дату по локалі. <br>
        Date.toLocaleString() - повертає рядок з датою і часом по локалі. <br>
        Date.toLocaleTimeString() - повертає рядок з лише годиною по локалі. <br>
        Date.toSource() - повертає рядок з вихідним кодом об'єкту. <br>
        Date.toString() - повертає рядок з датою і часом. <br>
        Date.toTimeString() - повертає рядок який містить тільки годину. <br>
        Date.toUTCString() - повертає рядок який містить дату і час по UTC. <br>
        Date.valueOf() - повертає примітивне значення об'єкту Data. <br>
    </p>
    <h2>Promise</h2>
    <p>Promise (обіцянка, проміс) - об'єкт, що представляє поточний стан асинхронної
        операції. Зручний спосіб організації асинхронного коду.
        У промісу є 2 стани:
        Pending - очікування, вихідний стан під час створення промісу.
        Settled – виконаний, яке у свою чергу ділиться на дві категорії: fullfilled – виконано
        успішно та rejected – виконано з помилкою.
        Спочатку проміс перебуває у стані очікування (pending), після чого може
        виконатися успішно (fulfilled) чи з помилкою (rejected). Коли проміс
        перетворюється на стан виконаний (settled), з результатом чи помилкою – це
        назавжди. Грубо кажучи, проміс - це заглушка для даних, значення яких ми не
        знаємо в момент його створення.
        Спосіб використання:
        Код, якому треба зробити щось асинхронно, створює обіцянку та повертає її.
        Зовнішній код, отримавши обіцянку, навішує на нього оброблювачі.
        По завершенні процесу асинхронний код переводить обіцянку в стан fulfilled або
        rejected. При цьому автоматично викликаються обробники у зовнішньому коді
    </p>
    <h2>Властивості промісу</h2>
    <p>Promise.length <br>
        Значення якості завжди дорівнює 1 (кількість аргументів конструктора). <br>
        Promise.prototype (en-US) <br>
        Прототип для конструктора Promise.
    </p>
    <h2>Методи</h2>
    <p>Promise.all(iterable) <br>
        Чекає на виконання всіх промісів або відхилення будь-якого з них.
        Повертає проміс, який здійсниться після виконання всіх промісів у iterable. У
        випадку, якщо будь-який з промісів буде відхилено, Promise.all також буде
        відхилено.
    </p>
    <p>Promise.allSettled(iterable) <br>
        Чекає на завершення всіх отриманих промісів (як виконання так і відхилення).
        Повертає проміс, який виконується, коли всі отримані проміси завершені (виконані
        або відхилені), що містить масив результатів виконання отриманих промісів.
    </p>
    <p>Promise.race(iterable) <b></b>
        Чекає на виконання або відхилення будь-якого з отриманих промісів.
        Повертає проміс, який буде виконаний або відхилений з результатом виконання
        першого виконаного або відхиленого промісу з iterable.
    </p>
    <p>Promise.reject(reason) <br>
        Повертає проміс, відхилений через reason.
    </p>
    <p>Promise.resolve(value) <br>
        Повертає проміс, виконаний результатом value.
    </p>
    <h2>Синтаксис створення проміса:</h2>
    <p>lОбіцянка створюється як екземпляр класу Promise з однією функцією як
        аргумент. Виклик конструктора негайно виконає функцію fn, передану як
        аргумент. Мета цієї функції полягає в інформуванні екземпляра (промісу), коли
        подія, з якою він пов'язаний, буде завершено. <br>
        const promise = new Promise((resolve, reject) => { <br>
        /* <br>
        * Ця функція буде викликана автоматично. У ній можна виконувати
        * будь-які асинхронні операції. Коли вони завершаться – потрібно
        * викликати одне з: resolve(результат) при успішному виконанні,
        * або reject(помилка) при помилці.
        */ <br>
        }); <br>
    </p>
    <h2>Використання</h2>
    <p>Після того, як проміс створено, з ним можна працювати використовуючи методи
        then та catch, які доступні через його прототип. Код пишеться так, ніби ми
        розмірковуємо про те, що може статися, якщо проміс виконається чи ні, не
        думаючи про тимчасові рамках <br>
        then <br>
        Дозволяє виконати код, в якому можна отримати доступ і обробити результат
        промісу. <br>
        promise.then(onResolve, onReject) <br>
        У метод передаються дві функції які будуть викликані коли проміс перейде в стан
        виконаний (settled). <br>
        onResolve(arg) - буде викликана при успішному виконанні промісу, і отримає
        результат промісу як аргумент (те, що передаємо виклик resolve). <br>
        onReject(arg) - буде викликана при виконанні промісу з помилкою, і отримає
        помилку як аргумент (те, що передаємо виклик reject).
    </p>
    <p>catch <br>
        Трохи далі ми дізнаємося про ланцюжки промісів, а поки що навчимося
        обробляти помилки не в колбеку на реject методу then, а в спеціальному методі
        catch. Обробляти помилки дуже зручно, використовуючи метод catch тільки один
        раз, в кінці ланцюжка. <br>
        promise.catch(onReject) <br>
        Хендлер для обробки стану reject виконається тільки якщо проміс виконається з
        помилкою (rejected). onReject(arg) буде викликана при виконанні промісу з
        помилкою і отримає помилку як аргумент (те, що передаємо у виклик reject).
    </p>
    <p>finally <br>
        Цей метод може бути корисним, якщо ви хочете виконати деяку обробку або
        очищення після того, як обіцянка буде виконана, незалежно від результату.
        Дозволяє виконати вказану callback-функцію після того, як обіцянку буде дозволено
        (виконано або відхилено). Дозволяє уникнути дублювання коду в обробниках then() та
        catch(). Повертає обіцянку. <br>
        promise.finally(() => { <br>
        // settled (fulfilled або rejected) br
        }); <br>
        Функція зворотного дзвінка не отримає жодних аргументів, оскільки не можна точно
        визначити, чи виконано обіцянку або відхилено. Тут буде виконуватися код, який
        залежить тільки від часу його виконання, значення промісу не важливо.
    </p>
    <script src="./index.js"></script>
    <script src="./hw12.js"></script>
</body>
</html>