// Конструктори
// Ім’я функції-конструктора повинно починатися з великої літери.
// Функції-конструктори повинні виконуватися лише з оператором "new".
// Звичайний синтаксис літерал об'єкта {} дозволяє створити один об'єкт. Але
// найчастіше потрібно створити багато однотипних об'єктів, динамічно, під час
// виконання програми. Для цього використовують функції конструктори,
// викликаючи їх за допомогою спеціального оператора new.
// Конструктор це звичайна функція до якої застосували оператор new. Це
// призводить до створення нового об'єкта та виклику функції у контексті цього
// об'єкта.
// Функція-конструктор
// Технічно, функції-конструктори – це звичайні функції. Однак є дві загальні
// домовленості:
// 1. Ім’я функції-конструктора повинно починатися з великої літери.
// 2. Функції-конструктори повинні виконуватися лише з оператором "new"
// Наприклад:
// function User(name) {
// this.name = name;
// this.isAdmin = false;
// }
// let user = new User("Джек");
// alert(user.name); // Джек
// alert(user.isAdmin); // false
// Коли функція виконується з new, відбуваються наступні кроки:
// Створюється новий порожній об’єкт, якому присвоюється this.
// Виконується тіло функції. Зазвичай воно модифікує this, додає до нього нові
// властивості.
// Повертається значення this.
// Будь-яка функція, крім стрілочної, може бути використана як конструктор, тобто
// викликана оператором new. При виклику стрілки через New буде помилка.
// Щоб відрізнити конструктор від звичайної функції, конструктори прийнято
// називати з великої літери, а саму назву відображати тип створюваного об'єкта.
// Ми вже працювали з конструкторами, вбудованими в мову: Object, Array, Number,
// String та інші.
// Використання конструкторів зручно при створенні безлічі об'єктів з одним
// набором властивостей, що мають різні значення. Тому таку функцію і називають
// конструктором - вона призначена для конструювання об'єктів за заздалегідь
// підготовленим шаблоном.

class CirclBox {
    constructor(selector) {
        this.$el = document.querySelector(selector);
    };

    hide() {
        this.$el.style.display = 'none';
    };

    show() {
        this.$el.style.display = 'block';
    };
};

class CirclItem extends CirclBox {
    constructor(option) {
        super(option.selector);
        this.$el.style.width = option.size + "px";
        this.$el.style.height = option.size + "px";
        this.$el.style.background = option.color;
        this.$el.style.borderRadius = "50%";
    };
};

const circleRed = new CirclItem({
    selector: '#circleRed',
    size: 50,
    color: 'red',
});

const circleYellow = new CirclItem({
    selector: '#circleYellow',
    size: 80,
    color: 'yellow',
});

const circlePink = new CirclItem({
    selector: '#circlePink',
    size: 100,
    color: 'pink',
});

const circleBlue = new CirclItem({
    selector: '#circleBlue',
    size: 120,
    color: 'blue',
});

const circleOrange = new CirclItem({
    selector: '#circleOrange',
    size: 140,
    color: 'orange',
});

//Object.prototype - прототип об'єкта Object.
// prototype властивість об'єкта Object яка повертає прототип об'єкта.
// Прототип - це звичайний об'єкт, який ділиться своєю поведінкою з іншими
// об'єктами - тобто стає батьком об'єкта. Прототип використовується в основному
// для наслідування.
// Майже всі об'єкти в JavaScript є екземплярами Object і успадковують властивості,
// методи від Object.prototype. Хоча ці властивості можуть бути перевизначені.
// Зміни в Object.prototype об'єкта розглядаються на всіх об'єктах через прототип
// ланцюжка, якщо властивості і методи не будуть перезаписані далі по ланцюжку
// прототипів.
// Object.prototype знаходиться на вершині ланцюжка прототипів.
// Властивості:
// Object.constructor - Визначає функцію, яка створює прототип об'єкта.
// Object.__ proto__ - Вказує на об'єкт, який використовувався в якості прототипу
// при інстанцірувані об'єкта.
// Object.__noSuchMethod__ - дозволяє визначити функцію, виконуються при
// виклику в якості методу не певного члена об'єкта.
// Object.__ count__ - використовувалося для повернення кількості
// перерахованих властивостей, певних безпосередньо на призначеному для
// користувача об'єкті, але було видалено.
// Object.__ parent__ -використовувалося для вказівки контексту об'єкта, але було
// видалено.
// Всі об'єкти в JavaScript є нащадками Object; всі об'єкти успадковують методи і
// властивості з прототипу об'єкта Object.prototype, хоча вони і можуть бути
// перевизначені. Наприклад, прототипи інших конструкторів скасовують
// властивість constructor і надають свої власні методи toString().
// Методи:
// Object.__defineGetter__() - асоціює функцію з властивістю, яка, при доступі до
// нього, виконує цю функцію і повертає її значення, що повертається.
// Object.__defineSetter__() - асоціює функцію з властивістю, яке, при його установці,
// виконує цю функцію, змінює властивість.
// Object.__ lookupGetter__() - повертає функцію, пов'язану із зазначеним
// властивістю методом __defineGetter__.
// Object.__lookupSetter__() - Повертає функцію, пов'язану із зазначеним
// властивістю методом __defineSetter__.
// Object.hasOwnProperty() - чи містить вказане властивість безпосередньо об'єкт,
// або він успадкував його по ланцюжку прототипів.
// Object.isPrototypeOf() - чи перебуває зазначений об'єкт в ланцюжку прототипів
// об'єкта, на якому був викликаний даний метод.
// Object.propertyIsEnumerable() - повертає логічне значення, яке вказує, чи
// встановлений внутрішній атрибут ECMAScript DontEnum.
// Object.toSource() - повертає рядок, що містить вихідний код об'єкта.
// Object.toLocaleString() - повертає рядкове представлення об'єкту згідно локалі.
// Object.toString() - повертає строкове представлення об'єкту.
// Object.unwatch() - видаляє точку спостереження (watchpoint) зі властивості
// об'єкта.
// Object.valueOf() - повертає значення примітиву зазначеного об'єкта.
// Object.watch() - додає точку спостереження (watchpoint) до властивості об'єкта.