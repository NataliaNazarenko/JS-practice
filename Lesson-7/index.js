// Конструктори
// Ім’я функції-конструктора повинно починатися з великої літери.
// Функції-конструктори повинні виконуватися лише з оператором "new".
// Звичайний синтаксис літерал об'єкта {} дозволяє створити один об'єкт. Але
// найчастіше потрібно створити багато однотипних об'єктів, динамічно, під час
// виконання програми. Для цього використовують функції конструктори,
// викликаючи їх за допомогою спеціального оператора new.
// Конструктор це звичайна функція до якої застосували оператор new. Це
// призводить до створення нового об'єкта та виклику функції у контексті цього
// об'єкта.
// Функція-конструктор
// Технічно, функції-конструктори – це звичайні функції. Однак є дві загальні
// домовленості:
// 1. Ім’я функції-конструктора повинно починатися з великої літери.
// 2. Функції-конструктори повинні виконуватися лише з оператором "new"
// Наприклад:
// function User(name) {
// this.name = name;
// this.isAdmin = false;
// }
// let user = new User("Джек");
// alert(user.name); // Джек
// alert(user.isAdmin); // false
// Коли функція виконується з new, відбуваються наступні кроки:
// Створюється новий порожній об’єкт, якому присвоюється this.
// Виконується тіло функції. Зазвичай воно модифікує this, додає до нього нові
// властивості.
// Повертається значення this.
// Будь-яка функція, крім стрілочної, може бути використана як конструктор, тобто
// викликана оператором new. При виклику стрілки через New буде помилка.
// Щоб відрізнити конструктор від звичайної функції, конструктори прийнято
// називати з великої літери, а саму назву відображати тип створюваного об'єкта.
// Ми вже працювали з конструкторами, вбудованими в мову: Object, Array, Number,
// String та інші.
// Використання конструкторів зручно при створенні безлічі об'єктів з одним
// набором властивостей, що мають різні значення. Тому таку функцію і називають
// конструктором - вона призначена для конструювання об'єктів за заздалегідь
// підготовленим шаблоном.

class CirclBox {
    constructor(selector) {
        this.$el = document.querySelector(selector);
    };

    hide() {
        this.$el.style.display = 'none';
    };

    show() {
        this.$el.style.display = 'block';
    };
};

class CirclItem extends CirclBox {
    constructor(option) {
        super(option.selector);
        this.$el.style.width = option.size + "px";
        this.$el.style.height = option.size + "px";
        this.$el.style.background = option.color;
        this.$el.style.borderRadius = "50%";
    };
};

const circleRed = new CirclItem({
    selector: '#circleRed',
    size: 50,
    color: 'red',
});

const circleYellow = new CirclItem({
    selector: '#circleYellow',
    size: 80,
    color: 'yellow',
});

const circlePink = new CirclItem({
    selector: '#circlePink',
    size: 100,
    color: 'pink',
});

const circleBlue = new CirclItem({
    selector: '#circleBlue',
    size: 120,
    color: 'blue',
});

const circleOrange = new CirclItem({
    selector: '#circleOrange',
    size: 140,
    color: 'orange',
});

//Object.prototype - прототип об'єкта Object.
// prototype властивість об'єкта Object яка повертає прототип об'єкта.
// Прототип - це звичайний об'єкт, який ділиться своєю поведінкою з іншими
// об'єктами - тобто стає батьком об'єкта. Прототип використовується в основному
// для наслідування.
// Майже всі об'єкти в JavaScript є екземплярами Object і успадковують властивості,
// методи від Object.prototype. Хоча ці властивості можуть бути перевизначені.
// Зміни в Object.prototype об'єкта розглядаються на всіх об'єктах через прототип
// ланцюжка, якщо властивості і методи не будуть перезаписані далі по ланцюжку
// прототипів.
// Object.prototype знаходиться на вершині ланцюжка прототипів.
// Властивості:
// Object.constructor - Визначає функцію, яка створює прототип об'єкта.
// Object.__ proto__ - Вказує на об'єкт, який використовувався в якості прототипу
// при інстанцірувані об'єкта.
// Object.__noSuchMethod__ - дозволяє визначити функцію, виконуються при
// виклику в якості методу не певного члена об'єкта.
// Object.__ count__ - використовувалося для повернення кількості
// перерахованих властивостей, певних безпосередньо на призначеному для
// користувача об'єкті, але було видалено.
// Object.__ parent__ -використовувалося для вказівки контексту об'єкта, але було
// видалено.
// Всі об'єкти в JavaScript є нащадками Object; всі об'єкти успадковують методи і
// властивості з прототипу об'єкта Object.prototype, хоча вони і можуть бути
// перевизначені. Наприклад, прототипи інших конструкторів скасовують
// властивість constructor і надають свої власні методи toString().
// Методи:
// Object.__defineGetter__() - асоціює функцію з властивістю, яка, при доступі до
// нього, виконує цю функцію і повертає її значення, що повертається.
// Object.__defineSetter__() - асоціює функцію з властивістю, яке, при його установці,
// виконує цю функцію, змінює властивість.
// Object.__ lookupGetter__() - повертає функцію, пов'язану із зазначеним
// властивістю методом __defineGetter__.
// Object.__lookupSetter__() - Повертає функцію, пов'язану із зазначеним
// властивістю методом __defineSetter__.
// Object.hasOwnProperty() - чи містить вказане властивість безпосередньо об'єкт,
// або він успадкував його по ланцюжку прототипів.
// Object.isPrototypeOf() - чи перебуває зазначений об'єкт в ланцюжку прототипів
// об'єкта, на якому був викликаний даний метод.
// Object.propertyIsEnumerable() - повертає логічне значення, яке вказує, чи
// встановлений внутрішній атрибут ECMAScript DontEnum.
// Object.toSource() - повертає рядок, що містить вихідний код об'єкта.
// Object.toLocaleString() - повертає рядкове представлення об'єкту згідно локалі.
// Object.toString() - повертає строкове представлення об'єкту.
// Object.unwatch() - видаляє точку спостереження (watchpoint) зі властивості
// об'єкта.
// Object.valueOf() - повертає значення примітиву зазначеного об'єкта.
// Object.watch() - додає точку спостереження (watchpoint) до властивості об'єкта.

function Car(name, color) {
    this.name = name;
    this.color = color;
};

Car.prototype.message = function() {
    console.log(`${this.name} is ${this.color} color`);
};

Car.prototype.start = function() {
    console.log(`${this.name} started`);
};

const BMW = new Car('BMW', 'black');
const Mercedes = new Car('Mercedes', 'white');

BMW.message();
Mercedes.message();
BMW.start();
Mercedes.start();

// Внутрішні методи [[Call]] та [[Construct]]
// Функції викликаються використовуючи два різні внутрішні методи: [[Call]] і
// [[Construct]].
// Коли функція викликається без new, виконується метод [[Call]], який виконує тіло
// функції так, як описано в коді.
// Коли функція викликається з new, виконується метод [[Construct]], який
// відповідає за створення нового об'єкта і виконання тіла функції з цим, що
// посилається на цей об'єкт.
// Не всі функції мають внутрішній метод [[Construct]], і тому всі функції можуть бути
// викликані через new. Стрілецькі функції не мають методу [[Construct]] і, тому, не
// можуть бути використані як конструктори.
// Створення методів у конструкторі
// Використання конструкторів для створення об’єктів дає велику гнучкість.
// Конструктор може мати параметри, які визначають, як побудувати об’єкт і що в
// нього помістити.
// Звичайно, ми можемо додати до this не лише властивості, але й методи.
// У наведеному нижче прикладі,
// new User(name) створює об’єкт із заданим name та методом sayHi:
// function User(name) {
// this.name = name;
// this.sayHi = function() {alert( "Моє ім’я: " + this.name );
// };
// }
// let john = new User("Джон"); john.sayHi(); // Моє ім’я: Джон

// Методи прототипів, об’єкти без __proto__
// Властивість __proto__ вважається застарілою (підтримується браузером відповідно до
// стандарту).
// Сучасні методи:
// Object.create(proto, [descriptors]) – створює пустий об’єкт з властивістю [[Prototype]], що
// посилається на переданий об’єкт proto, та необов’язковими для передачі
// дескрипторами властивостей descriptors.
// Object.getPrototypeOf(obj) – повертає значення [[Prototype]] об’єкту obj.
// Object.setPrototypeOf(obj, proto) – встановлює значення [[Prototype]] об’єкту obj рівне
// proto.
// Ці методи необхідно використовувати на відміну від __proto__.
// "Прості" об’єкти
// Як ми знаємо, об’єкти можуть використовуватися як асоціативні масиви для
// зберігання пар ключ/значення.
// …Проте якщо ми спробуємо зберегти створені користувачем ключі в ньому
// (наприклад, словник з користувацьким вводом), ми можемо спостерігати цікавий збій:
// усі ключі працюють правильно окрім "__proto__".
// Розгляньте приклад:
// let obj = {};
// let key = prompt("Введіть ключ"
// ,
// "__proto__");
// obj[key] = "певне значення";
// alert(obj[key]); // [object Object], не "певне значення"!
// В цьому випадку, якщо користувач введе __proto__, присвоєння проігнорується!
// Це не повинно дивувати нас. Властивість __proto__ є особливою: вона має бути або
// об’єктом або null. Рядок не може стати прототипом.
// Проте ми не намагалися реалізувати таку поведінку. Ми хотіли зберегти пари ключ/
// значення і при цьому ключ з назвою "__proto__" не зберігся. Тому це помилка!
// В першу чергу, для зберігання ми можемо просто використовувати Map замість
// простих об’єктів, тоді все працює правильно.
// Проте Object може також послужити нам, оскільки творці мови задумувались над
// цією проблемою вже дуже давно.
// __proto__ не є властивістю об’єкту, але є аксесором Object.prototype
// Таким чином, якщо obj.__proto__ зчитується або встановлюється, відповідний
// гетер/сетер викликається з прототипу та отримує/встановлює [[Prototype]].
// Як було сказано на початку цього розділу: __proto__ це спосіб доступу до
// [[Prototype]], але не є самим [[Prototype]].
// Тепер, коли ми хочемо використати об’єкт як асоціативний масив та уникнути
// таких проблем, ми можемо зробити це за допомогою невеликої хитрості:
// let obj = Object.create(null);
// let key = prompt("Введіть ключ"
// ,
// "__proto__");
// obj[key] = "певне значення";
// alert(obj[key]); // "певне значення"
// Object.create(null) створює пустий об’єкт без прототипу ([[Prototype]] дорівнює
// null):
// Таким чином, відсутні наслідувані гетер/сетер для __proto__. Тепер ми працюємо
// зі звичайною властивістю, тому приклад вище працює правильно.
// Ми можемо називати такі об’єкти “простими” або “чистим словниковим” об’єктом,
// тому що вони навіть простіше ніж звичайні об’єкти {...}.

let message = {
    messageHello() {
        console.log(`Hello ${this.name}`);
    },

    messageBey() {
        console.log(`Bey ${this/name}`);
    },
};

class NewUser {
    constructor(name) {
        this.name = name;
    };
};

Object.assign(NewUser.prototype, message);

new NewUser('Mango').messageHello();

// height = height ?? 100;
// @paran {number} X число
// @param {number} N піднесе в степінь

