// Конструктори
// Ім’я функції-конструктора повинно починатися з великої літери.
// Функції-конструктори повинні виконуватися лише з оператором "new".
// Звичайний синтаксис літерал об'єкта {} дозволяє створити один об'єкт. Але
// найчастіше потрібно створити багато однотипних об'єктів, динамічно, під час
// виконання програми. Для цього використовують функції конструктори,
// викликаючи їх за допомогою спеціального оператора new.
// Конструктор це звичайна функція до якої застосували оператор new. Це
// призводить до створення нового об'єкта та виклику функції у контексті цього
// об'єкта.
// Функція-конструктор
// Технічно, функції-конструктори – це звичайні функції. Однак є дві загальні
// домовленості:
// 1. Ім’я функції-конструктора повинно починатися з великої літери.
// 2. Функції-конструктори повинні виконуватися лише з оператором "new"
// Наприклад:
// function User(name) {
// this.name = name;
// this.isAdmin = false;
// }
// let user = new User("Джек");
// alert(user.name); // Джек
// alert(user.isAdmin); // false
// Коли функція виконується з new, відбуваються наступні кроки:
// Створюється новий порожній об’єкт, якому присвоюється this.
// Виконується тіло функції. Зазвичай воно модифікує this, додає до нього нові
// властивості.
// Повертається значення this.
// Будь-яка функція, крім стрілочної, може бути використана як конструктор, тобто
// викликана оператором new. При виклику стрілки через New буде помилка.
// Щоб відрізнити конструктор від звичайної функції, конструктори прийнято
// називати з великої літери, а саму назву відображати тип створюваного об'єкта.
// Ми вже працювали з конструкторами, вбудованими в мову: Object, Array, Number,
// String та інші.
// Використання конструкторів зручно при створенні безлічі об'єктів з одним
// набором властивостей, що мають різні значення. Тому таку функцію і називають
// конструктором - вона призначена для конструювання об'єктів за заздалегідь
// підготовленим шаблоном.

class CirclBox {
    constructor(selector) {
        this.$el = document.querySelector(selector);
    };

    hide() {
        this.$el.style.display = 'none';
    };

    show() {
        this.$el.style.display = 'block';
    };
};

class CirclItem extends CirclBox {
    constructor(option) {
        super(option.selector);
        this.$el.style.width = option.size + "px";
        this.$el.style.height = option.size + "px";
        this.$el.style.background = option.color;
        this.$el.style.borderRadius = "50%";
    };
};

const circleRed = new CirclItem({
    selector: '#circleRed',
    size: 50,
    color: 'red',
});

const circleYellow = new CirclItem({
    selector: '#circleYellow',
    size: 80,
    color: 'yellow',
});

const circlePink = new CirclItem({
    selector: '#circlePink',
    size: 100,
    color: 'pink',
});

const circleBlue = new CirclItem({
    selector: '#circleBlue',
    size: 120,
    color: 'blue',
});

const circleOrange = new CirclItem({
    selector: '#circleOrange',
    size: 140,
    color: 'orange',
});

