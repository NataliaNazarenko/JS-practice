<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-4</title>
</head>
<body>
    <h2>Функції</h2>
    <p>Досить часто нам потрібно виконати однакову дію в декількох місцях програми.
        Наприклад, нам треба показати якесь повідомлення, коли користувач входить
        або виходить з системи і може ще десь.
        Функції — це головні “будівельні блоки” програми. Вони дозволяють робити
        однакові дії багато разів без повторення коду.
        Функції можна уявити як чорну скриньку, вони отримують щось на вході (дані), і
        віддають щось на виході (результат виконання коду всередині функції).
        Функції є інструментом для структурування великих програм, зменшення
        повторень та ізолювання коду
    </p>
    <h2>Параметри</h2>
    <p>Ми можемо передати в функцію довільні дані використовуючи параметри.
        В наступному прикладі, функція має два параметри: from і text. <br>
        function showMessage(from, text) { // параметри: from, text <br>
        alert(from + ': ' + text);} <br>
        showMessage('Анна','Привіт!'); // Анна: Привіт! (*) <br>
        Якщо викликати функцію без аргументів, тоді відповідні значення стануть
        undefined.
    </p>
    <h2>Функціональний вираз</h2>
    <p>Функціональний вираз (function expression) - звичайне оголошення змінної,
        значення якої буде функцією.
        Оголосимо змінну add, і надамо їй функцію приймаючу 3 значення і повертає
        результат складання цих значень. <br>
        const add = function(a, b, c) { <br>
        return a + b + c; <br>
        }; <br>
        Ім'я функції це дія, дієслово, що починається з маленької літери, що
        відповідає на питання 'Що зробити?'. Наприклад: findSmallesNumber,
        fetchUserInfo, validateInput.
    </p>
    <p>Визначення функції починається з ключового слова function, за яким може йти
        необов'язкове ім'я функції.
        У круглих дужках йдуть параметри - перерахування даних, які функція буде
        отримувати з-за. Параметрів може бути кілька або взагалі їх не бути, тоді записуються
        просто порожні круглі дужки ().
        Далі йде тіло функції, укладене у фігурні дужки {}, що містить інструкції, які необхідно
        виконати при виклику функції. Тіло функції завжди укладають у фігурні дужки, навіть
        якщо воно складається з однієї інструкції.
        Оператор return визначає значення, що повертається. Коли інтерпретатор доходить доreturn, він відразу ж виходить з функції, і повертає це значення в місце коду, де функціябула викликана.
        Оператор return без виразу повертає значення undefined. При відсутності обороту в
        тілі функції вона все одно поверне значення undefined.
    </p>
    <p>Потім, коли необхідно, функція викликається за допомогою імені та круглих
        дужок, усередині яких можуть бути передані аргументи.
        Термін аргументи використовується під час виклику функції, коли ми передаємо
        значення у функцію.
        Термін параметри використовується при оголошенні функції, це ті локальні
        змінні всередині функції, які будуть записані значення аргументів під час її
        виклику.
        JavaScript важливий порядок оголошення параметрів функції. Немає ніякого
        іншого механізму пояснити інтерпретатору як значення аргументів функції при
        виклику пов'язані з параметрами.
        Порядок оголошення параметрів відповідає порядку передачі аргументів під
        час виклику функції: значення першого аргументу буде присвоєно першому
        параметру, другого аргументу другому параметру і т. д. Якщо параметрів буде
        менше аргументів, то параметрам без значень буде присвоєно undefined.
    </p>
    <h2>Стрілкові функції</h2>
    <p>Існує ще один простий та короткий синтаксис для створення функцій, який часто
        доцільніше використовувати замість Функціонального Виразу.
        Це так звані “стрілкові функції” <br>
        , а виглядають вони ось так: <br>
        let func = (arg1, arg2, ..., argN) => expression; <br>
        Цей код створить функцію func з аргументами arg1..argN, що обчислює
        expression з правого боку (використовуючи ці аргументи) та повертає його
        результат.
        Іншими словами, це приблизно те ж саме, що і: <br>
        let func = function(arg1, arg2, ..., argN) { <br>
        return expression; <br>
        };
    </p>
    <h2>Колбеки (функції зворотного виклику)</h2>
    <p>Розглянемо інші приклади передачі функції як значення та використання
        Функціональних Виразів.
        Для цього напишемо функцію ask(question, yes, no) з трьома параметрами: <br>
        question <br>
        Текст запитання <br>
        yes <br>
        Функція, що буде викликатись, якщо відповідь “Так” <br>
        no <br>
        Функція, що буде викликатись, якщо відповідь “Ні” <br>
        Функція повинна поставити запитання question і, залежно від відповіді
        користувача, викликати yes() або no(): <br>
        function ask(question, yes, no) { <br>
        if (confirm(question)) yes() <br>
        else no(); <br>
        } <br>
        function showOk() { <br>
        alert( "Ви погодились." ); <br>
        } <br>
        function showCancel() { <br>
        alert( "Ви скасували виконання." ); <br>
        } <br>
        // використання: функції showOk, showCancel передаються як аргументи для ask
        ask("Ви згодні?" <br>
        , showOk, showCancel);
    </p>
    <h2>Лексичне оточення (LexicalEnvironment)</h2>
    <p>Офіційна специфікація ES6 визначає цей термін як:
        Lexical Environment – це тип специфікації, який використовується для дозволу
        імен ідентифікаторів при пошуку конкретних змінних та функцій на основі
        лексичної структури вкладеності коду ECMAScript. Лексичне оточення (Lexical
        Environment) складається із запису середовища і, можливо, нульового посилання
        на зовнішнє Лексичне середовище.
        Розберемося докладніше.
        Я уявлю собі лексичне оточення як структуру, яка зберігає зв'язок
        ідентифікаторів контексту зі своїми значенням. Це свого роду сховище змінних,
        функцій, класів, оголошених у сфері видимості цього контексту.
        Технічно ЛО є об'єкт з двома властивостями: <br>
    </p>
    <p>запис оточення (саме тут зберігаються всі оголошення) <br>
        посилання на ЛО породжуючого контексту.
    </p>
    <p>Через посилання на контекст-батька поточного контексту ми можемо у разі
        потреби отримати посилання на «контекст-дідусь» контексту-батька і так далі до
        глобального контексту, посилання на батько якого буде null.
        З цього визначення випливає, що Лексичне оточення - це зв'язок сутності з
        контекстами, що її породили. <br>
        let x = 10; <br>
        let y = 20; <br>
        const foo = z => { <br>
        let x = 100; <br>
        return x + y + z; <br>
        } <br>
        foo(30); <br>
        поверне 150. ЛО для foo буде виглядати <br>
        так {record: {z: 30, x: 100}, parent: __parent}; <br>
        // __parent буде вказувати на глобальне ЛО <br>
        {record: {x: 10, y: 20}, parent: null}
    </p>
    <p>Технічно процес дозволу імен ідентифікаторів відбуватиметься так - послідовне
        опитування об'єктів у ланцюзі ЛВ доти, доки не буде знайдено потрібний
        ідентифікатор. Якщо ідентифікатор не знайдено, ReferenceError.
        Лексичне оточення створюється та наповнюється на етапі створення контексту.
        Коли поточний контекст закінчує своє виконання, він видаляється зі стека
        викликів
        Лексичне оточення може продовжувати жити до тих пір, поки на нього є хоч одне
        посилання. Це одна з переваг сучасного підходу до проектування мов
        програмування
    </p>
    <h2>Контексти і виклики</h2>
    <p>При виклику функції всередині її тіла можуть викликатися інші функції, а в них
        інші і т. д. JavaScript однопоточна (в основному) мова, тобто в одну одиницю часу
        може виконуватися тільки одна операція.
        Це означає, що вже викликані функції, які закінчили своє виконання, повинні
        чекати виконання функцій викликаних у собі, щоб продовжити своє виконання.
        Відповідно необхідний механізм зберігання списку функцій, які були викликані,
        але ще не закінчили своє виконання, і управління порядком виконання цих
        функцій, і саме за це відповідає стек контекстів виконання.
        Стек – структура даних, яка працює за принципом останнім прийшов – першим
        вийшов (LIFO – Last In, First Out). Останнє, що ви додали в стек, буде видалено з
        нього першим, тобто можна додати або видалити елементи лише з верхівки
        стека.
    </p>
    <p>Контекст виконання (execution context) - внутрішня конструкція мови для
        відстеження виконання функції, що містить метаінформацію про її виклик.
        Глобальний контекст виконання (global execution context) – це контекст є за
        замовчуванням, сам файл скрипта – це функція яка запускається на виконання.
        Контекст виконання функції (functional execution context) - створюється щоразу
        під час виклику функції.
        Стек викликів (Execution Context stack, call stack) – внутрішня констуркція двигуна,
        що містить усі контексти виконання.
        Stack frame (кадр стека, запис стека) - структура, яка додається на стек при
        виклику функції. Зберігає деяку метаінформацію: ім'я функції, аргументи які були
        передані під час виклику та номер рядка в якому відбувся виклик.
    </p>
    <script src="./index.js"></script>
    <script src="./hw4.js"></script>
</body>
</html>