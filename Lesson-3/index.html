<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-3</title>
</head>
<body>
    <h2>Масиви</h2>
    <p>Масив - структура даних для зберігання та маніпулювання колекцією
        індексованих значень. Використовуються для зберігання впорядкованих
        колекцій даних, наприклад, списку курортів, товарів, клієнтів у готелі тощо.
        Синтаксис для створення нового масиву - квадратні дужки [] зі списком
        елементів розділених комами. У масиві може зберігатися будь-яка кількість
        елементів будь-якого типу.
        Оголошення
        Існує два типи синтаксу для створення порожнього масиву: <br>
        let arr = new Array(); <br>
        let arr = []; <br>
    </p>
    <p>Майже завжди використовують другий тип синтаксису. Ми можемо вказати
        початкові елементи масиву у квадратних дужках: <br>
        let fruits = ["Apple","Orange","Plum"]; <br>
        Елементи масиву нумеруються починаючи з нуля.
        Ми можемо отримати елемент масиву, вказавши його номер в квадратних дужках: <br>
        let fruits = ["Apple","Orange","Plum"]; <br>
        alert( fruits[0] ); // Apple <br>
        alert( fruits[1] ); // Orange <br>
        alert( fruits[2] ); // Plum <br>
    </p>
    <h2>Перевизначення</h2> 
    <p>Елементи масиву можна замінювати та додавати, звертаючись до елемента
        масиву за індексом. <br>
        fruits[2] = 'Pear'; <br>
        …Або додати новий: <br>
        fruits[3] = 'Lemon'; // тепер ["Apple","Orange","Pear","Lemon"] <br>
        Загальна кількість елементів масиву зберігається у його властивості length: <br>
        let fruits = ["Apple","Orange","Plum"]; <br>
        alert( fruits.length ); // 3 <br>
        У масивах можуть зберігатись елементи будь-якого типу. <br>
        // різні типи значень br
        let arr = [ 'Apple', { name: 'John' }, true, function() { alert('hello'); } ]; <br>
    </p>
    <h2>Методи масиву</h2>
    <p>Методи push(), pop(), shift(), unshift()</p>
    <p>push() — дозволяє додати один або кілька елементів до кінця масиву. Метод
        повертає значення властивості length, що визначає кількість елементів у масиві. <br>
        pop() — видаляє елемент із кінця масиву <br>
        shift() — видаляє елемент із початку масиву та повертає його (елемента)
        значення <br>
        unshift() — додає елемент на початок масиву. <br>
        splice - Метод arr.splice – це універсальний «швейцарський ніж» для
        роботи з масивами. Вміє все: додавати, видаляти і замінювати елементи. <br>
        синтаксис: arr.splice(position, num) <br>
        let arr = ["I","study","JavaScript"]; <br>
        arr.splice(1, 1); // з індексу 1 видалимо 1 елемент
    </p>
    <p>position — вказує позицію (індекс) першого елемента видалення <br>
        num - визначає кількість елементів, що видаляються <br>
        Метод splice змінює вихідний масив та повертає масив, що містить віддалені
        елементи. <br>
        Метод slice() - Синтаксис методу slice() однаковий для рядків та масивів. Його
        просто запам'ятати. Він дозволяє витягувати елементи підмножини масиву і
        додавати в новий масив. Найчастіше використовується для створення копії
        частини або цілого вихідного масиву. <br>
        arr.slice(begin, end. - Копіює елементи від begin до, але не включаючи, end.
        Обидва аргументи (begin та end) не обов'язкові.
        Параметр begin визначає індекс, з якого слід розпочинати вилучення.
    </p>
    <p>Параметр end визначає індекс елемента, на якому слід закінчити вилучення. <br>
        Метод slice не включає елемент з ідексом end у вилучені елементи. <br>
        Якщо begin і end не вказані, копіювання буде з початку масиву, з індексу 0, тобто
        скопіюється весь масив. <br>
        Якщо не вказати параметр end, метод slice використовуватиме довжину масиву
        (length) для параметра end. <br>
        Метод slice не змінює вихідний масив, а повертає новий масив, що містить копію
        елементів вихідного. <br>
        Можна використовувати негативні індекси, вони відраховуються з кінця.
    </p>
    <h2>concat</h2>
    <p>Метод arr.concat створює новий масив, в який копіює дані з інших масивів та
        додаткові значення. <br>
        arr.concat(arg1, arg2...) <br>
        Він приймає будь-яку кількість аргументів – масивів або значень. <br>
        Результатом є новий масив, що містить елементи з arr, потімarg1, arg2 тощо. <br>
        Якщо аргумент argN є масивом, то всі його елементи копіюються. В іншому
        випадку буде скопійовано сам аргумент. <br>
        const oldClients = ['Mango' , 'Ajax','Poly','Kiwi']; <br>
        const newClients = ['Monkong','Singu']; <br>
        const allClients = oldClients.concat(newClients); <br>
        console.log(allClients); <br>
        // ["Mango", "Ajax","Poly","Kiwi","Monkong","Singu"]
    </p>
    <p>Методи arr.indexOf, arr.lastIndexOf та arr.includes мають однаковий синтаксис і
        роблять по суті те ж саме, що і їх рядкові аналоги, але працюють з елементами
        замість символів: <br>
        arr.indexOf(item, from) – шукає item, починаючи з індексу from, і повертає індекс,
        на якому був знайдений шуканий елемент, в іншому випадку&#8209;1. <br>
        arr.lastIndexOf(item, from) – те ж саме, але шукає справа наліво. <br>
        arr.includes(item, from) – шукає item, починаючи з індексу from, і повертає true,
        якщо пошук успішний.
    </p>
    <h2>Цикл</h2>
    <p>Цикл — конструкція, що управляє, у високорівневих мовах програмування,
        призначена для організації багаторазового виконання набору інструкцій.
        Тіло циклу – послідовність інструкцій, призначена для багаторазового
        виконання.
        Ітерація – одиничне виконання тіла циклу.
    </p>
    <p>Умова виходу - вираз, що визначає в черговий раз виконуватися ітерація, або
        цикл завершиться.
        Лічильник - змінна, що зберігає поточний номер ітерації. Цикл необов'язково
        містить лічильник, і не повинен бути один, умова виходу з циклу може залежати
        від кількох змінних у циклі змінних.
        Виконання будь-якого циклу включає:
        початкову ініціалізацію змінних циклу
        перевірку умови виходу
        виконання тіла циклу
        оновлення змінної циклу на кожній ітерації
    </p>
    <h2>Цикл “while”</h2>
    <p>Цикл while має такий синтаксис: <br>
        while (умова) { <br>
        // код <br>
        // так зване "тіло циклу" <br>
        } <br>
        Доки умова є вірною, виконується код із тіла циклу. <br>
        Наприклад, цикл нижче виводить i поки i < 3: <br>
        let i = 0; <br>
        while (i < 3) { // показується 0, далі 1, потім 2 <br>
        alert( i ); <br>
        i++; <br>
        } <br>
    </p>
    <h2>Цикл “do…while”</h2>
    <p>Перевірка умови може бути переміщена нижче тіла циклу використовуючи
        do..while синтаксис: <br>
        do { <br>
        // тіло циклу <br>
        } while (умова); <br>
        Цикл спочатку виконує тіло, а потім перевіряє умову, і поки умова є true, цикл
        виконується знову і знову. <br>
        Наприклад: <br>
        let i = 0; <br>
        do { <br>
        alert( i ); <br>
        i++; <br>
        } while (i < 3); <br>
    </p>
    <h2>Цикл for</h2>
    <p>Цикл із лічильником — цикл, у якому деяка змінна змінює своє значення від
        заданого початкового до кінцевого значення, з деяким кроком, і кожного
        значення цієї змінної тіло циклу виконується один раз.
        У більшості процедурних мов програмування реалізується оператором for, у
        якому вказується лічильник, необхідну кількість ітерацій та крок, з яким
        змінюється лічильник.
        Алгоритм виконання циклу for:
        Ініціалізація (initialization) - вираз ініціалізації виконується один раз, коли
        починається цикл. Використовується для ініціалізації змінної-лічильника. Якщо
        використовується ключове слово let, змінна лічильника є локальною для циклу.
    </p>
    <p>Умова (condition, test) - вираз, що оцінюється перед кожною ітерацією циклу. Тіло
        циклу виконується лише тоді, коли вираз умови набуває значення true. Цикл
        завершується, якщо значення буде false. <br>
        Тіло (statements) – виконується у разі задоволення умови. <br>
        Пост-вираз (post-expression) - виконується після тіла кожної ітерації циклу, але
        перед перевіркою умови. Використовується для оновлення змінної-лічильника. <br>
        const max = 10; <br>
        for (let i = 0; i < max; i += 1) { <br>
        console.log(i); <br>
        } <br>
    </p>
    <h2>Переривання циклу: “break”</h2>
    <p>Зазвичай, цикл завершується, коли умова стає false. <br>
        Але ми можемо в будь-який момент вийти з циклу, використавши спеціальну
        директиву break. <br>
        for (let i = 0; i < 10; i += 1) { <br>
        if (i === 5) { <br>
        console.log('5 ітерація!'); <br>
        break; <br>
        }
        } <br>
    </p>
    <h2>Продовження з наступної ітерації</h2>
    <p>Директива continue — це “полегшена версія” break. Вона не зупиняє весь цикл.
        Натомість, вона зупиняє поточну ітерацію і починає виконання циклу спочатку з
        наступної ітерації (якщо умова циклу досі вірна).
        Її зручно використовувати коли закінчили з поточною ітерацією і хочемо продовжити знаступної.
        Цикл нижче використовує continue щоб вивести лише непарні значення: <br>
        for (let i = 0; i < 10; i++) { <br>
        // якщо умова справджується, тоді пропускаємо решту тіла циклу і починаємо з
        наступної ітерації <br>
        if (i % 2 == 0) continue; <br>
        alert(i); // 1, потім 3, 5, 7, 9} <br>
    </p>
    <h2>Область видимості</h2>
    <p>Область видимості змінних (variable scope) – доступність змінних у певному місці
        коду. Є кілька областей видимості: глобальна, блокова, eval та функції.
        Глобальна область видимості використовується за умовчанням. Усі і всі мають
        доступ до змінних оголошених у ній. Змінні оголошені у глобальній області
        видимості вразливі, оскільки може змінити будь-яку ділянку коду.
        Будь-яка конструкція використовує фігурні дужки {} (умови, цикли, функції тощо)
        створює нову локальну область видимості, і змінні, оголошені в цій області
        видимості, використовуючи let або const, не доступні поза цим блоком
    </p>
    <script src="./index.js"></script>
    <script src="./hw3.js"></script>
</body>
</html>