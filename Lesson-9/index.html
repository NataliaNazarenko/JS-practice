<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-9</title>
    <link rel="stylesheet" href="./styles.css">
</head>
<body>
    <h2>Подія</h2>
    <p>Подія – це сигнал від браузера у тому, що щось сталося. <br>
        Події використовуються для реакції на дії відвідувача та виконання коду. <br>
        Події стають у чергу та обробляються у порядку надходження, асинхронно,
        незалежно. <br>
        Існує багато видів подій, розглянемо деякі з них. <br>
        click - відбувається, коли клацнули на елемент лівою кнопкою миші <br>
        submit - відвідувач надіслав форму <br>
        focus - відвідувач фокусується на елементі, наприклад, натискає на input <br>
        contextmenu – відбувається, коли клацнули на елемент правою кнопкою миші. <br>
        mouseover / mouseout – коли миша наводиться на / залишає елемент. <br>
        mousedown / mouseup – коли натиснули / відпустили кнопку миші на елементі. <br>
        mousemove – під час руху миші.
    </p>
    <h2>Події клавіатури:</h2>
    <p>keydown та keyup – коли користувач натискає / відпускає клавішу.</p>
    <h2>Події елементів форми:</h2>
    <p>submit – користувач надіслав форму form. <br>
        focus – користувач фокусується на елементі, наприклад, натискає на input.
    </p>
    <h2>Події документа:</h2>
    <p>DOMContentLoaded – коли HTML завантажено й оброблено, DOM документа повністю
        побудований і доступний.
    </p>
    <h2>CSS події:</h2>
    <p>transitionend – коли CSS-анімацію завершено.</p>
    <h2>Обробники подій</h2>
    <p>Події можна призначити обробник, тобто функцію, яка спрацює, щойно подія
        сталася. <br>
        Саме завдяки обробникам JavaScript код може реагувати на дії користувача.
        Є кілька способів призначити події обробник. Зараз ми їх розглянемо,
        починаючи з найпростішого. <br>
        Використання атрибута HTML <br>
        Обробник може бути призначений прямо в розмітці, атрибуті, який називається
        on event. <br>
        Наприклад, щоб призначити обробник події click на елементі input, можна
        використовувати атрибут onclick, ось так: <br>
        value="Натисни мене" onclick="alert('Клік!')" type="button"
        При натисканні мишкою на кнопці виконається код, вказаний в атрибуті onclick.
    </p>

    <div class="buttonGroup">
        <button class="buttonItem" id="btn1">1</button>
        <button class="buttonItem" id="btn2">2</button>
        <button class="buttonItem" id="btn3">3</button>
        <button class="buttonItem" id="btn4">4</button>
        <button class="buttonItem" id="btn5">5</button>
        <button class="buttonItem" id="btn6">6</button>
        <button class="buttonItem" id="add">Add</button>
        <button class="buttonItem" id="remove">Remove</button>
        <button class="buttonItem" id="click">Click Me</button>
        <button class="buttonItem" id="click-btn">Click Button</button>
    </div>
    <form class="form">
        <input type="text" class="input" placeholder="login" class="input">
        <input type="password" placeholder="password" class="input">
        <button type="submit" class="btn-submit">Submit</button>
    </form>

    <div class="parent" id="parent">Parent
        <div class="child" id="child">Child
            <div class="item" id="item">Item</div>
        </div>
    </div>

    <ul class="nav">
        <li class="liItem">1</li>
        <li class="liItem">2</li>
        <li class="liItem">3</li>
        <li class="liItem">4</li>
        <li class="liItem">5</li>
        <li class="liItem">6</li>
    </ul>

    <div class="ball"></div>

    <div>
        <div id="text">Hello</div>
        <button id="btn">Click</button>
    </div>

    <button id="hideButton">Приховати елемент</button>

    <ul id="tree">
        <li class="parent">Parent Node
            <ul class="hidden">
                <li>Child Node 1</li>
                <li>Child Node 2</li>
            </ul>
        </li>
        <li class="parent">Parent Node
            <ul class="hidden">
                <li>Child Node 3</li>
                <li>Child Node 4</li>
            </ul>
        </li>
    </ul>
    <h2>Порядок спрацювання подій</h2>
    <p>Одна дія може викликати кілька подій. Наприклад, клік викликає спочатку стрілку
        вниз, а потім натисніть і клацніть. У випадках, коли одна дія генерує кілька подій,
        їх порядок фіксований. Тобто, обробники викликатимуться в порядку mousedown
        → mouseup → click.
        Кожна подія опрацьовується незалежно. Наприклад, при натисканні, події
        мишіup і click виникають одночасно, але обробляються послідовно. Спочатку
        повністю завершується обробка mouseup, потім запускається click.
    </p>
    <h2>Слухачі подій</h2>
    <p>Для того, щоб елемент реагував на дії користувача, на нього необхідно повісити
        слухача (обробник) події. Тобто функцію, яка спрацює, як тільки подія відбулася.
        Саме завдяки слухачам подій скрипт може реагувати на дії користувача.
        Методи elem.addEventListener() і elem.removeEventListener() це сучасний спосіб
        призначити або видалити обробник, при цьому можна використовувати скільки
        завгодно обробників на одному типі події.
    </p>
    <h2>addEventListener</h2>
    <p>Синтаксис додавання обробника: <br>
        element.addEventListener(event, handler, [options]); <br>
        event <br>
        Назва події, наприклад "click". <br>
        handler <br>
        Посилання на функцію-обробник. <br>
        options <br>
        Додатковий об’єкт із властивостями:
    </p>
    <p>once: якщо true, тоді обробник буде автоматично вилучений після виконання. <br>
        capture: фаза, на якій повинен спрацювати обробник, докладніше про це буде розказано у
        розділі Bubbling and capturing. Так історично склалося, що options може бути false/true, це
        те саме, що {capture: false/true}. <br>
        passive: якщо true, тоді обробник ніколи не викличе preventDefault(), докладніше про це
        буде розказано у розділі Типові дії браузера.
    </p>
    <h2>Для видалення обробника слід використовувати removeEventListene</h2>
    <p>element.removeEventListener(event, handler, [options]); <br>
        Метод addEventListener дозволяє додавати кілька обробників на одну подію
        одного елемента.
    </p>
    <h2>Форми: подія та метод submit</h2>
    <p>Подія submit ініціюється, коли форма надсилається. Зазвичай це
        використовується для перевірки форми перед відправкою на сервер або щоб
        запобігти її відправленню та обробці в JavaScript.
        Метод form.submit() дозволяє ініціювати відправку форми за допомогою
        JavaScript. Ми можемо використовувати його для динамічного створення та
        надсилання власних форм на сервер.
        Подія submit
        Виникає під час відправлення форми. Його застосовують для валідації форми
        форми перед відправкою. Щоб відправити форму, відвідувач має два способи:
        Натиснути кнопку з type="submit"
        Натиснути клавішу Enter, перебуваючи в якомусь полі форми
        Хоч би який спосіб вибрав відвідувач – буде згенеровано подію submit. В
        обробнику цієї події можна перевірити дані та виконати дії за результатами
        перевірки.
    </p>
    <h2>Метод: submit</h2>
    <p>Щоб надіслати форму на сервер вручну, ми можемо викликати form.submit().
        Тоді подія submit не генерується. Передбачається, що якщо програміст викликає
        form.submit(), то сценарій вже здійснив всю пов’язану обробку.
        Іноді це використовується для створення та надсилання форми вручну.
    </p>
    <h2>Клавіатура: keydown та keyup</h2>
    <p>Є три основні події клавіатури: keydown, keypress і keyup. При натисканні клавіші
        спочатку відбувається keydown, після чого keypress, і тільки потім keyup, коли
        клавішу віджали. <br>
        Події keydown та keyup спрацьовують при натисканні будь-якої клавіші,
        включаючи службові. А ось keypress спрацьовує лише якщо натиснута символьна
        клавіша, тобто натискання призводить до появи символу. Клавіші, що
        управляють, такі як Ctrl, Shift, Alt та інші, не генерують подію keypress. <br>
        Властивість KeyboardEvent.key доступна для читання і повертає значення клавіші,
        натиснутої користувачем, беручи до уваги стан клавіш модифікаторів, таких як
        shiftKey, а також поточну мову та модель клавіатури. <br>
        Властивість KeyboardEvent.code є фізичною клавішею на клавіатурі (на відміну від
        символу, згенерованого натисканням клавіші). Іншими словами, ця властивість
        повертає значення, яке не змінюється за допомогою клавіатури або стану клавішмодифікаторів.
    </p>
    <h2>Фокусування</h2>
    <p>Елемент отримує фокус, натиснувши на ньому мишкою, клавіші Tab або
        вибравши на планшеті. Момент отримання фокусу та втрати дуже важливий, при
        отриманні фокусу ми можемо підвантажити дані для автодоповнення, почати
        відстежувати зміни. При втраті фокусу перевірити введені дані.
        При фокусуванні на елемент відбувається подія focus, а коли фокус зникає,
        наприклад, відвідувач клікає в іншому місці екрана, відбувається подія blur.
        За замовчуванням багато елементів не можуть отримати фокусування.
        Наприклад, якщо натиснути на div, то фокусування на ньому не відбудеться. До
        речі, фокус може бути тільки на одному елементі в одиницю часу, а поточний
        елемент, на якому фокус доступний як document.activeElement.
        Активувати або скасувати фокус можна програмно, викликавши в коді
        однойменні методи elem.focus() та elem.blur() елемента.
    </p>
    <h2>Подія change</h2>
    <p>Відбувається після зміни елемента форми, коли зміна зафіксована. Для input:text
        або textarea подія відбудеться не при кожному введенні, а при втраті фокусу, що
        не завжди зручно.
        Наприклад, поки що ви набираєте щось у текстовому полі — події немає. Але
        щойно фокус зник, відбудеться подія change. Для інших елементів, наприклад
        select, input:checkbox і input:radio, воно спрацьовує відразу при виборі значення.
    </p>
    <h2>Подія input</h2>
    <p>Спрацьовує лише на текстових елементах, input:text і textarea, за зміни значення
        елемента. Не чекає втрати фокусу, на відміну від зміни.
        У сучасних браузерах input – найголовніша подія для роботи з текстовим
        елементом форми. Саме його, а не keydown або keypress, слід використовувати
    </p>
    <h2>Поширення подій</h2>
    <p>Поширення подій (event propagation) - важлива, але незрозуміла тема, коли
        йдеться про події. Це всеосяжний термін, який включає три різні етапи життя
        події: затоплення, націлення і спливання.
        Поширення події двонаправлене - воно починається на window, йде до цільового
        елементу і закінчується на window. Поширення часто неправильно
        використовується як синонім стадії спливу. Щоразу, коли відбувається подія,
        відбувається її поширення.
        При настанні події вона проходить через три обов'язкові фази:
        Capture phase - подія починається на window і тоне (проходить через всі вузлипредки) до найглибшого цільового елемента, де сталася подія.
        Target phase - подія дійшла до найглибшого цільового елемента. Цей етап
        включає лише повідомлення вузла, у якому сталася подія.
        Bubbling phase - заключна фаза, подія спливає від найглибшого, цільового
        елемента, через усі вузли-предки, до window
    </p>
    <h2>Приклад делегування: дії в розмітці</h2>
    <p>Скажімо, ми хочемо створити меню з кнопками «Зберегти», «Завантажити»,
        «Пошук» і так далі. А ще є об’єкт з методами save, load, search… Як їх поєднати?
        Перше, що спадає на думку – це призначити окремий обробник кожній кнопці.
        Але є більш елегантне рішення. Ми можемо додати один обробник до всього
        меню та атрибути data-action до кожної кнопки відповідно до методів, які вони
        викликають:
        button data-action="save" <br>
        Клікніть, щоб Зберегти <br>
        button <br>
    </p>
    <p>Зауважте, що this.onClick прив’язаний до this у (*). Це важливо, тому що інакше this
        в ньому посилатиметься на елемент DOM (elem), а не на об’єкт Menu, і this[action]
        буде не тим, який нам потрібен.
        Отже, які переваги дає нам тут делегування?
        Нам не потрібно писати код, щоб призначити обробник кожній кнопці. Достатньо
        створити один метод і помістити його в розмітку.
        Структура HTML гнучка, ми можемо в будь-який момент додати/видалити кнопки.
        Ми також можемо використовувати класи .action-save, .action-load, але підхід з
        використанням атрибутів data-action вважається семантично кращим. Крім того,
        його можна використовувати в правилах CSS.
        Делегування подій можна також використовувати для додавання певної
        «поведінки» елементам декларативно, за допомогою спеціальих атрибутів та
        класів.
    </p>
    <p>Шаблон складається з двох частин: <br>
        Ми додаємо спеціальний атрибут до елемента, який описує його поведінку. <br>
        За допомогою делегування ставиться один обробник на документ, що
        відстежує усі події і, якщо елемент має атрибут, виконує відповідну дію
    </p>
    <h2>Drag'n'Drop з подіями миші</h2>
    <p>Drag’n’Drop – відмінний спосіб поліпшити інтерфейс. Захоплення елементу
        мишкою і його перенесення візуально спростять що завгодно: від копіювання і
        переміщення документів (як у файлових менеджерах) до оформлення
        замовлення (“покласти до кошику”).
        У сучасному стандарті HTML5 є розділ про Drag and Drop – який містить спеціальні
        події саме для Drag’n’Drop перенесення, такі як dragstart, dragend та інші.
        Ці події дозволяють нам підтримувати спеціальні види drag’n’drop, наприклад,
        обробляти перенесення файлу з файлового менеджера ОС у вікно браузеру.
        Після чого JavaScript може отримати доступ до вмісту таких файлів.
        Але у браузерних подій Drag Events є обмеження. Наприклад, ми не можемо
        заборонити перенесення з певної області. Також ми не можемо зробити
        перенесення тільки “горизонтальним” або тільки “вертикальним”. І є багато інших
        завдань по перетяганню, які не можуть бути виконані за їх допомогою. Крім того,
        підтримка таких подій на мобільних пристроях дуже низька
    </p>
    <h2>Drag’n’Drop алгоритм</h2>
    <p>Наш алгоритм Drag’n’Drop виглядає таким чином: <br>
        На mousedown – підготувати елемент до переміщення, якщо це необхідно
        (наприклад, створити його клон, додати до нього клас або щось ще). <br>
        Потім, на mousemove перемістити його, змінивши значення left/top при
        позиціюванні position: absolute. <br>
        На mouseup – виконати усі дії, пов’язані із завершенням перенесення.
    </p>
    <script src="./index.js"></script>
    <script src="./hw9.js"></script>
</body>
</html>