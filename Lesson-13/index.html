<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-13</title>
</head>
<body>
    <h2>Протоколи передачі даних</h2>
    <p>Протокол — набір правил та угод, які використовуються під час передачі даних у
        мережі.
        Перед тим як користувач побачить вміст сайту на екрані, браузер робить запит на
        сервер, щоб отримати цей вміст. HTML-файл, зображення, стилі, скрипти - кожен
        елемент надходить із сервера. <br>
        TCP/IP <br>
        Основний протокол мережі Internet. Це два протоколи тісно пов'язані між собою.
        TCP (Transmission Control Protocol) - протокол керування передачею. Визначає,
        яким чином інформація має бути розбита на пакети та надіслана каналами
        зв'язку. TCP має пакети в потрібному порядку, а також перевіряє кожен пакет на
        наявність помилок при передачі. <br>
        IP (Internet Protocol) — кожен інформаційний пакет містить IP-адреси комп'ютеравідправника та комп'ютера-отримувача. Спеціальні комп'ютери, які називають
        маршрутизаторами, використовуючи IP-адреси, направляють інформаційні
        пакети в потрібну сторону, тобто до зазначеного в них одержувача.
    </p>
    <h2>HTTP</h2>
    <p>При HTTP-з'єднанні клієнт (браузер) робить запит на сервер, в результаті чого
        отримує відповідь. Сервер не може бути ініціатором запиту лише клієнт. Ця
        модель не підходить у випадку, коли серверу необхідно повідомити клієнт про
        якусь подію, наприклад нове повідомлення в чаті.
        Кожне з'єднання фінальне, це означає, що сервер, після автету, забуває все про
        клієнт. У такій моделі кожне HTTP-з'єднання (відповідь чи запит) несе у собі
        велику кількість службової інформації про клієнта та сервер. Відкриття з'єднання
        та доставка службової інформації у кожному повідомленні впливають на
        швидкість запиту.
        Це означає, що для розробки програм з роботою в реальному часі, технологія
        клієнт-сервер, за стандартним HTTP-протоколом, не підходить.
    </p>
    <p>HTTPS - це надстойка над HTTP-протоколом, в якій всі повідомлення між клієнтом та
        сервером шифруються з метою підвищення безпеки. Забезпечує захист від атак, що
        базуються на прослуховуванні з'єднання. Дані передаються поверх криптографічних
        протоколів SSL чи TLS. Дефолтний TCP-порт - 443.
        При спілкуванні через звичайне з'єднання HTTP всі дані передаються у вигляді
        тексту і можуть бути прочитані всіма, хто отримав доступ до з'єднання між клієнтом і
        сервером.
        Якщо користувач робить покупки онлайн і заповнює форму замовлення, що містить
        інформацію про кредитну картку, їх фінансові дані набагато легше вкрасти, якщо
        вони передаються у вигляді тексту. З HTTPS дані будуть зашифровані, і хакер не
        зможе їх розшифрувати, тому що для розшифровки потрібний доступ до закритого
        ключа, який зберігається на сервері.
        Інформація про клієнта, наприклад номери кредитних карток, зашифрована і не
        може бути перехоплена у розшифрованому вигляді.
        Відвідувачі можуть підтвердити, що сайт безпечний, подивившись на іконку ліворуч
        від адресного рядка, захищені дії позначаються і іконкою замку.
        Клієнти з більшою ймовірністю будуть довіряти і купувати з сайтів, що
        використовують HTTPS.
    </p>
    <h2>Веб-сокети (Web Sockets)</h2>
    <p>Веб-сокети (Web Sockets) – це технологія, яка дозволяє створювати та
        підтримувати неприривне, двонаправлене з'єднання між клієнтом (браузером) та
        сервером для обміну даними у реальному часі.
        Все починається з HTTP-запиту, в якому є хедер upgrade, що повідомляє сервер
        про те, що клієнт хоче встановити з'єднання через веб-сокет. Вебсокет
        використовує ws:// схему (протокол) для HTTP і wss:// як еквівалент HTTPS.
        Якщо сервер підтримує веб-сокет, підтверджується відповідь. Це називається
        handshake - рукостискання.
        Після рукостискання, HTTP-з'єднання замінюється на WebSocket-з'єднання яке
        використовує той самий TCP/IP-протокол. Після чого клієнт та сервер можуть
        надсилати оповіщення без обмежень.
        Дані передаються у вигляді повідомлень (message), кожне з яких складається з
        одного або кількох кадрів (frame). Кожен кадр супроводжується невеликим
        відрізком даних, що містять мінімальну службову інформацію, щоб на клієнті
        кадри можна було зібрати в правильному порядку.
    </p>
    <h2>CRUD</h2>
    <p>CRUD - створення (create), читання (read), оновлення (update) та видалення
        (delete), чотири основні методи для взаємодії з ресурсами REST API.
        У REST-архітектурі CRUD відповідає наступним HTTP-методам.
    </p>
    <p>POST (create) – створити новий ресурс</p>
    <p>GET (read) - отримати набір ресурсів або певний ресурс за ідентифікатором</p>
    <p>PUT (update) або PATCH (update) – оновити ресурс за ідентифікатором</p>
    <p>DELETE (delete) - видалити ресурс за ідентифікатором</p>
    <h2>Читання</h2>
    <p>Якщо пост має унікальне поле, як title в цьому випадку, його можна отримати
        безпосередньо через get(): <br>
        title = "CRUD" <br>
        crud_post = Post.objects.get(title=title) <br>
        Такий запис наочніший і зручніший, ніж використання фільтра <br>
        Post.objects.filter(title=title)[0]. <br>
        Якщо посту із заголовком "CRUD" не опиниться в базі, ви отримаєте помилку:
        models.DoesNotExist: Post matching query не існує.
        Це звичайний виняток, його можна перехопити та обробити, хоча є й деякі
        особливості.
    </p>
    <h2>Cтворення</h2>
    <p>Щоб створити нову посаду, є метод create. Ось так створюється новий пост
        Post.objects.create(title="Заголовок нового посту" <br>
        , text="Текст нового посту") <br>
        Тепер він збережений і лежить у БД: <br>
        post = Post.objects.get(title="Заголовок нового поста") <br>
        print(post.title) <br>
        # Заголовок нового посту
    </p>
    <h2>Вилучення</h2>
    <p>Видаляти можна як окремі пости, так і цілі вибірки Queryset. Робиться це методом <br>
        delete(): <br>
        post = Post.objects.get(title="Новий заголовок") <br>
        post.delete() # Видалили пост з БД <br>
        all_posts = Post.objects.all() <br>
        all_posts.delete() # Видалили всі пости з БД
    </p>
    <h2>Редагування</h2>
    <p>Для редагування об'єкта посту потрібно спочатку витягнути його з БД.
        Наприклад, так: <br>
        post = Post.objects.get(title="Заголовок нового поста") <br>
        Тепер у нас є об'єкт посту, і ми можемо змінювати його атрибути. Так могло б
        виглядати редагування заголовка: <br>
        post = Post.objects.get(title="Заголовок нового поста") <br>
        post.title = "Від чого вимерли динозаври?" <br>
        Але це не спрацює. Зміни потрібно надіслати до бази даних, інакше вони
        пропадуть разом із завершенням програми. За збереження відповідає метод <br>
        .save(): <br>
        post = Post.objects.get(title="Заголовок нового поста") <br>
        post.title = "Від чого вимерли динозаври?" <br>
        post.save()
    </p>
    <h2>REST API</h2>
    <p>Сервер – комп'ютер із спеціальним програмним забезпеченням. Контролем
        роботи сервера займається системний адміністратор.
        Дата-центр - спеціально обладнаний майданчик із цілодобовою технічною
        підтримкою для розміщених серверів. Забезпечує їхню безперебійну роботу.
        Бекенд – програма, розташована на сервері і здатна обробити вхідні HTTP-запити
        і має набір готових дій на певні запити.
        API (інтерфейс прикладного програмування) – набір чітко визначених правил
        зв'язку між різними програмними компонентами. Інтерфейс описує, що можна
        попросити програму зробити і що вийде в результаті.
        REST (representational state transfer) — стиль бекенд-архітектури, що ґрунтується
        на наборі принципів, які описують як мережеві ресурси визначаються та
        адресуються.
        REST API – бекенд побудований за принципом REST. Служить прошарком між
        веб-програмою та базою даних. Має стандартний інтерфейс звернення до
        ресурсів. Працюючи як веб-сайт, ми надсилаємо HTTP-запит із клієнта на сервер,
        а у відповідь замість HTML-сторінки отримуємо дані в JSON-форматі.
    </p>
    <button id="get">GET</button>
    <button id="post">POST</button>
    <button id="put">PUT</button>
    <button id="delete">DELETE</button>
    <h2>Формат запиту</h2>
    <p>REST-сервіс вимагає, щоб клієнт робив запит на додавання, вилучення або зміну даних. <br>
        Запит зазвичай складається з: <br>
        HTTP-метод - визначає, яку операцію виконувати. <br>
        Заголовок — дозволяє клієнту надсилати інформацію про запит. <br>
        Шлях – шлях до ресурсу. Доступні шляхи описуються у документації бекенда. <br>
        Тіло — додатковий блок запиту, який містить дані.
    </p>
    <h2>Заголовки</h2>
    <p>Заголовки містять службову інформацію, що стосується користувача або контенту
        запиту, і як клієнт збирається обробляти надану йому інформацію.
        Наприклад тип контенту, який клієнт може обробити у відповіді від сервера (заголовок
        Accept) або який описує тип ресурсу, який клієнт відправляє серверу або сервер
        відправляє клієнту (заголовок Content-Type).
        MIME-типи - варіанти типів контенту. Використовуються для вказівки вмісту зарослі та
        відповіді, складаються з типу та підтипу, які розділені косою рисою /.
        Наприклад, текстовий файл, який містить HTML, буде описаний типом text/html. Якщо
        файл містить CSS, він буде описаний як text/css. Дані у форматі JSON будуть описані як
        application/json. Якщо клієнт чекає на text/css, а отримує application/json, він не зможе
        розпізнати і обробити контент.
    </p>
    <h2>Коди відповідей</h2>
    <p>На запит клієнта сервер відправляє відповідь. Відповідь містить код стану, щоб
        інформувати клієнта про результат операції. Коди поділяються на групи. <br>
        1XX - несуть інформаційне призначення <br>
        2XX - коди успішного проведення операції <br>
        3XX - описують все, що пов'язано з перенапрямком <br>
        4XX - вказують на помилки клієнта <br>
        5XX - вказують на помилки на стороні сервера
    </p>
    <p>200 (OK) – стандартна відповідь для успішних HTTP-запитів <br>
        201 (Created) - стандартна відповідь для HTTP-запиту, що призвела до успішного
        створення ресурсу <br>
        400 (Bad Request) - запит не може бути оброблений через неправильний
        синтаксис запиту або іншої помилки клієнта. <br>
        401 (Unauthorized) – для доступу до ресурсу потрібна авторизація. <br>
        403 (Forbidden) - клієнт не має дозволу на доступ до цього ресурсу. <br>
        404 (Not Found) – в даний час ресурс не знайдений. Можливо, він був вилучений
        чи ще не існує.
    </p>
    <h2>Fetch API</h2>
    <p>Fetch API — надає інтерфейс, набір методів та властивостей для відправлення,
        отримання та обробки ресурсів від сервера.
        Це XMLHttpRequest нового покоління. Він надає покращений інтерфейс для складання
        запитів до сервера та побудований на обіцянках (promise). <br>
        fetch(url, options) <br>
        url - обов'язковий шлях до даних, які ви хочете отримати. <br>
        options — необов'язковий об'єкт налаштувань запиту. Містить службову інформацію:
        метод (за умовчанням GET), заголовки, тіло тощо. <br>
        Повертає проміс, який містить відповідь сервера.</p>
        <p>method - рядок з назвою методу запиту: "GET","HEAD","POST". <br>
            headers - об'єкт заголовок запиту. <br>
            body - тіло запиту. <br>
            mode – режим крос-доменості: "same-origin", "no-cors","cors". <br>
            credentials – чи відправляти куки: "same-origin","include","omit". <br>
            cache – режим кешування: "default", "no-store", "reload", "no-cache", "force-cache", "only-ifcached" <br>
            redirect – режим переадресації: "follow" або "error".
        </p>
        <h2>fetch()</h2>
        <p>fetch() метод об'єкта window який дозволяє робити AJAX запити на основі Promise.
            fetch() повертає Promise який при отримані відповіді від сервера виконує вказану
            функцію в якій передається об'єкт response як параметр.
        </p>
        <h2>response</h2>
        <p>response містить наступні властивості і методи: <br>
            clone() - повертає копію об'єкту. <br>
            arrayBuffer() - повертає Promise результатом якого буде масив даних. <br>
            blob() - повертає Promise результатом якого будуть двійкові дані. <br>
            formData() - повертані Promise результатом якого будуть дані FormData. <br>
            json() - повертає Promise результатом якого будуть дані формату JSON. <br>
            text() - повертає Promise результатом якого будуть текстові дані. <br>
            type - рядок з назвою типу даних. <br>
            url - URL адреса відповіді від сервера.
        </p>
        <p>status - код статусу відповіді. <br>
            statusText - назва статусу відповіді. <br>
            ok - логічне значення,чи завантажено без помилок тобто статус від 200 до 299. <br>
            bodyUsed - логічне значення, чи завантажено body
        </p>
        <h2>headers</h2>
        <p>headers - об'єкт для роботи з заголовком. Містить наступні методи: <br>
            append() - додає значення у заголовок. <br>
            delete() - видаляє значення з заголовка. <br>
            get() - повертає вказане значення заголовка. <br>
            set() - задає значення. <br>
            getAll() - повертає усі заголовки <br>
            fetch() не підтримує синхроного запиту, а лише асинхроний.
            Тому якщо Вам необхідний синхроний запит - використовуйте XMLHttpRequest
        </p>
        <h2>Async/await</h2>
    <script src="./index.js"></script>
    <script src="./hw13.js"></script>
</body>
</html>