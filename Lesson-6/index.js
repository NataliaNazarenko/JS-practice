// Процедурне програмування — набір не пов'язаних функцій і змінних для
// зберігання та обробки інформації. 

const summa = 20000;
const month = 12;
const p = 1000;

const credit = (summa, date, p) => {
    return summa + p * date;
};

console.log(credit(summa, month, p));

// Об'єктно-Орієнтоване Програмування (ООП) - один з методів програмування,
// який розглядає програму як множину «об'єктів», що взаємодіють між собою.
// ООП представляє програмне забезпечення як сукупність взаємних об'єктів, а не
// просто набір команд чи функцій як у традиційному програмуванні.

const sumCredit = {
    summa: 20000,
    month: 12,
    p: 1000,
    result() {
        return this.summa + this.p * this.month;
    },
};

console.log(sumCredit.result());

// Клас - спосіб опису сутності, що визначає стан і поведінку, що залежить від цього
// стану, а також правила для взаємодії з цією сутністю (контракт).

// class Bank {
//     static type = 'Privat';
//     constructor(options) {
//         this.summa = options.summa;
//         this.month = options.month;
//         this.p = options.p;
//     };

//     credit() {
//         return console.log("I am Privat");
//     };
// };

// const userBank = new Bank({
//     summa: 50000,
//     month: 24,
//     p: 1500,
// });

// userBank.credit();
// console.log(userBank.type); //undefined
// console.log(Bank.type);

// class newBank extends Bank {
//     constructor(options) {
//       super(options);
//       this.card = options.card;
//    };

//    credit() {
//     super.credit();
//     return console.log("I am Aval");
//    };
// };

// const userNewBank = new newBank({
//     summa: 150000,
//     month: 36,
//     p: 2500,
//     card: true,
// });

// console.log(userNewBank.card);
// console.log(userNewBank.credit());

// get and set 

class User {
    constructor(props) {
        this.name = props.name;
    };

    firstName = '';
    lastName = '';
    age = '';
    city = '';

    set name(newName) {
        const newRow = newName.split(" ");
        this.firstName = newRow[0];
        this.lastName = newRow[1];
    };

    get name() {
        return `First name : ${this.firstName} , Last name : ${this.lastName}`;
    };
};

const newUserNata = new User({
    name: 'Natalia Nazarenko',
});

const newUserDasha = new User({
    name: 'Dasha Heppy',
});

console.log(newUserNata);
console.log(newUserDasha);

// prototype

const pr = [1, 2, 3];
console.log(pr);

const r = {
    x: 1,
    y: 2,
};

const t = Object.create(r);
console.log(t);
console.log(t.x);

// приклад 1

// const Manager = function(name, sale) {
//     this.name = name;
//     this.sale = sale;

    // this.sales = function() {
    //     this.sale +=1;
    // };
// };

// const anna = new Manager("Anna", 2);
// const mango = new Manager("Mango", 5);

// console.log(anna.sale);
// anna.sales();
// console.log(anna.sale);

// Manager.prototype.sales = function() {
//     this.sale +=1
// };

// console.log(anna.sale);
// anna.sales();
// console.log(anna.sale);

// console.dir(Manager);

// приклад 2

// class CoffeMachine {
//     _water = 0;
//     #waterLimit = 500;

//     constructor(power) {
//         this.power = power;
//     };

//     set waterAmount(value) {
//         if(value < 0) {
//             value = 0;
//         };
//         this._water = value;
//     };
// };

// let coffeMaghine = new CoffeMachine(1500);

// console.log(coffeMaghine);
// coffeMaghine.waterAmount = 20;
// console.log(coffeMaghine);


// Об'єкт

// Об'єкт (примірник) - це окремий представник класу, що має конкретний стан і
// поведінку, що повністю визначається класом. Це те, що створено за кресленням,
// тобто за описом із класу.
// Говорячи простою мовою, об'єкт має конкретні значення властивостей та методи,
// що працюють із цими властивостями на основі правил, заданих у класі. У даному
// прикладі, якщо клас це якийсь абстрактний телефон на кресленні, то об'єкт — це
// конкретний телефон, яким ви користуєтесь
// Інтерфейс
// Коли ми підходимо до автомата з кавою або сідаємо за кермо автомобіля, існує
// певний набір елементів керування, з якими ми можемо взаємодіяти.
// Інтерфейс – це набір властивостей та методів класу, доступних для використання
// під час роботи з екземпляром.
// Насправді, інтерфейс специфікує клас, чітко визначаючи всі можливі дії над ним.
// Хороший приклад інтерфейсу - панель приладів автомобіля, яка дозволяє
// викликати такі методи як збільшення швидкості, гальмування, поворот,
// перемикання передач, включення фар і т. п.
// При описі інтерфейсу класу дуже важливо дотриматися балансу між гнучкістю і
// простотою. Клас із простим інтерфейсом буде легко використовувати, але
// існуватимуть завдання, які за допомогою нього вирішити буде не під силу. Якщо
// інтерфейс буде гнучким, то швидше за все, він складатиметься з досить складних
// методів з великою кількістю параметрів, які дозволятимуть робити дуже багато,
// але його використання буде пов'язане з великими складнощами та ризиком
// зробити помилку, щось переплутавши.
// Парадигми
// ООП побудовано на чотирьох основних поняттях: інкапсуляція, абстракція,
// наслідування та поліморфізм.
// Інкапсуляція
// Внутрішні процеси роботи телефону досить складні. Але всі ці дії приховані від
// користувача і дозволяють йому дзвонити і писати, не замислюючись, що
// відбувається всередині. Саме приховування внутрішніх процесів, що відбуваються
// в телефоні, дозволяє ефективно використовувати його навіть новачкам. Це і є
// інкапсуляція.
// Інкапсуляція (encapsulation) - це властивість системи, що дозволяє об'єднати дані
// та методи, що працюють з ними, у класі та приховати деталі реалізації від
// користувача.
// Інкапсуляція пов'язана з поняттям інтерфейсу класу. Все те, що не входить до
// інтерфейсу, інкапсулюється (приховано) у класі. Користувач може працювати з
// усім функціоналом через інтерфейс, не замислюючись про те, як реалізований
// функціонал.
// Абстракція
// Коли ми телефонуємо ми не замислюватиметься про хімічний склад фарби
// панелі, особливості взаємодії внутрішніх деталей тощо. Однак це не
// заважає нам використовувати весь функціонал
// Абстрагування (abstraction) — це спосіб виділити набір значних показників
// об'єкта, крім розгляду незначні.
// Наслідування
// Уявімо що інженерам поставили завдання розробки та випуску
// модельного ряду сучасніших сматфонів. При цьому вони вже мають стару
// модель, яка відмінно зарекомендувала себе. Очевидно, що інженери не
// проектуватимуть новий телефон з нуля, а взявши за основу попереднє
// покоління, внесуть низку конструктивних змін.
// Усі модифікації матимуть більшість властивостей колишньої моделі. При цьому
// кожна з моделей реалізуватиме деяку нову функціональність або конструктивну
// особливість. У даному випадку ми маємо справу з успадкуванням.
// Спадкування (inheritance) - це властивість системи, що дозволяє описати новий
// клас на основі вже існуючого, з частково або повністю функціоналом, що
// запозичується. Клас, від якого виробляється успадкування, називається базовим,
// батьківським чи суперкласом. Новий клас називається нащадком, спадкоємцем
// чи похідним класом.
// Якщо взяти приклад із життя, у нас є HTML-елементи. У наступних модулях ми
// дізнаємося, що всі вони представлені об'єктами. У них є загальні властивості та
// методи для керування станом. Замість того, щоб додавати загальні властивості на
// кожен тип елемента, ми можемо описати їх у класі HTMLElement, і ті елементи,
// яким потрібен подібний інтерфейс, можуть успадковувати HTMLElement.
// Спадкування допомагає зменшити обсяг коду, що повторюється.
// Поліморфізм
// Було б не дуже зручно, якби всі телефони функціонували по різному і власник
// андроїду не міг зателефонувати з айосу чи навпаки.
// Вся справа в тому, що основні елементи використання телефону мають одну й ту
// саму конструкцію та принцип дії. По суті, можна сказати, що всі сматфони мають
// той самий інтерфейс, а користувач, абстрагуючись від сутності смартфону, працює
// саме з цим інтерфейсом. Незалежно від того, яким чином буде реалізовуватись
// дзвінок, інтерфейс залишиться тим самим.
// Поліморфізм (polymorphism) - це властивість системи дозволяє використовувати
// об'єкти з однаковим інтерфейсом без інформації про тип і внутрішню структуру
// об'єкта. Дозволяє перевизначати у класах спадкоємців реалізації методів
// базового класу.
