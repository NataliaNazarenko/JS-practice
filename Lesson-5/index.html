<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson-5</title>
</head>
<body>
    <h2>Замикання</h2>
    <p>Замикання (closure) - це зв'язок між функцією та її ланцюжком областей
        видимості.
        Цей механізм можливий завдяки лексичному оточенню. При виклику функції, її
        лексичне оточення отримує посилання ту область видимості, де функція було
        оголошено (зовнішнє лексичне оточення), цим отримуючи доступом до змінним
        із неї, буквально утримуючи у пам'яті таблицю доступних змінних.
        Разом, замикання це термін який описує здатність функції запам'ятовувати
        лексичне оточення в якому вона була оголошена, і продовжувати отримувати
        доступ до змінних з цього лексичного оточення незалежно від того, де вона була
        викликана.
        Тобто: функції автоматично запам’ятовують, де вони були створені,
        використовуючи приховану властивість [[Environment]], а потім їхній код може
        отримати доступ до зовнішніх змінних.
    </p>
    <h2>this</h2>
    <p>Ключове слово this є однією з найзаплутаніших частин JavaScript на старті
        вивчення.
        Необхідно засвоїти лише одне правило для визначення this.
        Значення контексту всередині функції визначаться над момент її створення, а
        момент виклику. Тобто значення цього визначається тим, як викликається
        функція, а не де вона була оголошена.
        У глобальній області видимості, якщо скрипт виконується не в строгому режимі,
        this посилається на об'єкт window. У строгому режимі значення this, в глобальній
        області видимості, буде undefined.
        Якщо функція була викликана як метод об'єкта, контекст буде посилатися на
        об'єкт, частиною якого є метод.
    </p>
    <h2>Методи об’єкту,"this"</h2>
    <p>Об’єкти зазвичай створюються для представлення сутностей реального світу,
        таких як користувачі, замовлення тощо: <br>
        let user = { <br>
        name: "Іван", <br>
        age: 30 <br>
        }; <br>
        І в реальному світі користувач може діяти: вибрати щось із кошика для покупок,
        авторизуватися, виходити із системи тощо.
        Дії представлені в JavaScript функціями у властивостях об’єкта. <br>
        user.sayHi = function() {alert("Привіт!");}; user.sayHi(); // Привіт! <br>
        Як правило, метод об’єкта повинен отримувати доступ до інформації, що
        зберігається в об’єкті, для виконання своєї роботи.
        Наприклад, коду всередині user.sayHi() може знадобитися ім’я, що зберігається в
        об’єкті user.
        Для доступу до інформації всередині об’єкта метод може використовувати
        ключове слово this
    </p>
    <h2>this у функціях зворотного виклику</h2>
    <p>Коли ми передаємо метод, який використовує this, як параметр, який буде
        використовуватися як функція зворотного виклику, буде проблема. Вирішення
        цієї проблеми розглядається в наступній секції. <br>
        const hotel = { <br>
        name: 'Resort Hotel', <br>
        showThis() { <br>
        console.log(this); <br>
        }, <br>
        }; <br>
        Під час виклику fn, callback буде посиланням на функцію showThis об'єкта hotel. Її
        виклик відбувається у глобальному контексті, про hotel вона нічого не знає.
        Відповідно this не посилатиметься на hotel
        const fn = function(callback) { <br>
            callback(); <br>
            }; <br>
            Передається посилання на функцію, а її виклик. <br>
            fn(hotel.showThis); <br>
            
    </p>
    <h2>Стрілочні функції</h2>
    <p>Стрілочні функції не мають свого this. На відміну від звичайних функцій, змінити
        значення цієї всередині стрілки після її оголошення не можна
    </p>
    <h2>Методи функцій call, apply, bind</h2>
    <p>Запам'ятати правило використання call досить легко: метод call викличе функцію
        fnпередавши її це посилання на об'єкт obj, а також аргументи arg1, arg2 і т.д. <br>
        const userInfo = { <br>
        name: "name", <br>
        age: 98, <br>
        logInfo: function (job) { <br>
        console.group(`${name} info:`); <br>
        console.log(`Name is : ${this.name}`); <br>
        console.log(`Age is : ${this.age}`); <br>
        console.log(`Job is : ${job}`); <br>
        console.groupEnd(); <br>
        }, <br>
        }; <br>
        const Vano = { <br>
        name: "Ivan", <br>
        age: 45, <br>
        }; <br>
        userInfo.logInfo.call(Vano, "developer"); <br>
        </p>
        <p>Метод apply повний аналог методу call крім того, що синтаксис виклику
            аргументів вимагає не перерахування, а масив.  <br>
            onst showUserInfo = { <br>
            name: name, <br>
            logInfo: function (job, city) { <br>
            console.group(`${name} info:`); <br>
            console.log(`Name is : ${this.name}`); <br>
            console.log(`Age is : ${this.age}`); <br>
            console.log(`Job is : ${job}`); <br>
            console.log(`City is : ${city}`); <br>
            console.groupEnd(); <br>
            }, <br>
            }; <br>
            const Vano = { <br>
            name: "Ivan", <br>
            }; <br>
            showUserInfo.logInfo.apply(Vano, ["developer","Lviv"]);
        </p>
        <p>Ми розглянули випадки, коли миттєво необхідно викликати функцію з іншим
            контекстом, для цього використовуються методи call і apply. Але у випадку функції
            зворотного дзвінка, коли необхідно не викликати функцію на місці, а передати
            посилання на цю функцію, причому з прив'язаним контекстом, call і apply не
            підходять. Метод bind дозволяє вирішити це завдання
        </p>
        <p>Метод bind створює копію функції fn з прив'язаним контекстом obj та
            аргументами arg1, arg2 тощо, після чого повертає її як результат своєї роботи. В
            результаті ми отримуємо копію функції з прив'язаним контекстом, яку можна
            передати куди завгодно і викликати будь-коли.
            Найчастіше метод bind використовується для прив'язки контексту передачі
            методів об'єкта як функцій зворотного виклику. Візьмемо проблемний приклад із
            попередньої секції. Завдання прив'язки контесту ми можемо вирішити
            використовуючи метод bind, передавши функцією зворотного виклику копію
            методу з прив'язаним контекстом.
        </p>
    <script src="./index.js"></script>
    <script src="./hw5.js"></script>
</body>
</html>